{
  "Canvas Context Setup": {
    "prefix": "canvas-context",
    "body": [
      "const canvas = document.getElementById('${1:gameCanvas}');",
      "const ctx = canvas.getContext('2d');",
      "",
      "// Responsive canvas setup",
      "function resizeCanvas() {",
      "  const container = canvas.parentElement;",
      "  const containerWidth = container.clientWidth;",
      "  const containerHeight = container.clientHeight;",
      "  ",
      "  canvas.width = Math.min(containerWidth, ${2:800});",
      "  canvas.height = Math.min(containerHeight, ${3:600});",
      "  ",
      "  // Maintain aspect ratio",
      "  const aspectRatio = ${2:800} / ${3:600};",
      "  if (canvas.width / canvas.height > aspectRatio) {",
      "    canvas.width = canvas.height * aspectRatio;",
      "  } else {",
      "    canvas.height = canvas.width / aspectRatio;",
      "  }",
      "}",
      "",
      "window.addEventListener('resize', resizeCanvas);",
      "resizeCanvas();"
    ],
    "description": "Canvas setup with responsive design for retro games"
  },
  "Game Loop Structure": {
    "prefix": "game-loop",
    "body": [
      "class ${1:GameEngine} {",
      "  constructor() {",
      "    this.gameState = 'menu'; // menu, playing, paused, gameOver",
      "    this.lastFrameTime = 0;",
      "    this.targetFPS = 60;",
      "    this.frameInterval = 1000 / this.targetFPS;",
      "    ",
      "    this.bindEvents();",
      "    this.gameLoop();",
      "  }",
      "",
      "  gameLoop() {",
      "    const currentTime = performance.now();",
      "    const deltaTime = currentTime - this.lastFrameTime;",
      "",
      "    if (deltaTime >= this.frameInterval) {",
      "      this.update(deltaTime);",
      "      this.render();",
      "      this.lastFrameTime = currentTime;",
      "    }",
      "",
      "    requestAnimationFrame(() => this.gameLoop());",
      "  }",
      "",
      "  update(deltaTime) {",
      "    switch (this.gameState) {",
      "      case 'playing':",
      "        this.updateGame(deltaTime);",
      "        break;",
      "      case 'menu':",
      "        this.updateMenu(deltaTime);",
      "        break;",
      "    }",
      "  }",
      "",
      "  render() {",
      "    // Clear canvas with retro background",
      "    ctx.fillStyle = '#000011';",
      "    ctx.fillRect(0, 0, canvas.width, canvas.height);",
      "",
      "    switch (this.gameState) {",
      "      case 'playing':",
      "        this.renderGame();",
      "        break;",
      "      case 'menu':",
      "        this.renderMenu();",
      "        break;",
      "    }",
      "  }",
      "",
      "  updateGame(deltaTime) {",
      "    ${2:// Game logic here}",
      "  }",
      "",
      "  renderGame() {",
      "    ${3:// Game rendering here}",
      "  }",
      "",
      "  updateMenu(deltaTime) {",
      "    ${4:// Menu logic here}",
      "  }",
      "",
      "  renderMenu() {",
      "    ${5:// Menu rendering here}",
      "  }",
      "",
      "  bindEvents() {",
      "    // Keyboard events",
      "    document.addEventListener('keydown', (e) => this.handleKeyDown(e));",
      "    document.addEventListener('keyup', (e) => this.handleKeyUp(e));",
      "    ",
      "    // Mobile touch events",
      "    canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });",
      "    canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });",
      "    canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e), { passive: false });",
      "  }",
      "",
      "  handleKeyDown(e) {",
      "    ${6:// Keyboard input handling}",
      "  }",
      "",
      "  handleKeyUp(e) {",
      "    ${7:// Keyboard release handling}",
      "  }",
      "",
      "  handleTouchStart(e) {",
      "    e.preventDefault();",
      "    ${8:// Touch input handling}",
      "  }",
      "",
      "  handleTouchMove(e) {",
      "    e.preventDefault();",
      "    ${9:// Touch move handling}",
      "  }",
      "",
      "  handleTouchEnd(e) {",
      "    e.preventDefault();",
      "    ${10:// Touch end handling}",
      "  }",
      "}"
    ],
    "description": "Complete game loop structure with 60fps optimization and mobile support"
  },
  "TDD Audit Tasks": {
    "prefix": "audit-tasks",
    "body": [
      "runAuditTasks() {",
      "  const results = [];",
      "  ",
      "  // Structure & Architecture Tests",
      "  const hasLicense = document.head.innerHTML.includes('© GG, MIT License');",
      "  results.push({ name: 'MIT License Header', pass: hasLicense, critical: true });",
      "  ",
      "  const validStates = ['menu', 'playing', 'paused', 'gameOver'];",
      "  results.push({ name: 'Valid Game State', pass: validStates.includes(this.gameState), critical: true });",
      "  ",
      "  // Performance Tests",
      "  const frameRateOK = this.lastFrameTime && (performance.now() - this.lastFrameTime) < 20;",
      "  results.push({ name: 'Frame Rate 50fps+', pass: frameRateOK, critical: true });",
      "  ",
      "  // UI/UX Tests",
      "  const backLink = document.querySelector('a[href*=\"index.html\"]');",
      "  const hasInicioText = backLink && backLink.textContent.includes('INICIO');",
      "  results.push({ name: 'Navigation \"INICIO\"', pass: hasInicioText, critical: false });",
      "  ",
      "  const htmlLang = document.documentElement.lang;",
      "  const isSpanish = htmlLang === 'es' && document.body.textContent.includes('INICIO');",
      "  results.push({ name: 'Language Consistency', pass: isSpanish, critical: false });",
      "  ",
      "  const hasInstructions = document.querySelector('details') && ",
      "    document.body.textContent.includes('¿Cómo jugar?');",
      "  results.push({ name: 'Instructions Section', pass: hasInstructions, critical: false });",
      "  ",
      "  // Technical Tests",
      "  const canvas = document.querySelector('canvas');",
      "  const isResponsive = canvas && getComputedStyle(canvas).maxWidth === '100%';",
      "  results.push({ name: 'Responsive Canvas', pass: isResponsive, critical: true });",
      "  ",
      "  // Accessibility Tests",
      "  const hasKeyboardNav = document.querySelector('[tabindex]') || document.querySelector('button');",
      "  results.push({ name: 'Keyboard Navigation', pass: hasKeyboardNav, critical: false });",
      "  ",
      "  // Log results",
      "  console.log('🔍 TDD Audit Results:');",
      "  console.table(results);",
      "  ",
      "  const criticalFails = results.filter(r => !r.pass && r.critical);",
      "  const allCriticalPassed = criticalFails.length === 0;",
      "  ",
      "  console.log(allCriticalPassed ? '✅ All CRITICAL tests PASSED' : '❌ CRITICAL tests FAILED');",
      "  if (criticalFails.length > 0) {",
      "    console.error('❌ Critical failures:', criticalFails.map(f => f.name));",
      "  }",
      "  ",
      "  return { allPassed: results.every(r => r.pass), criticalPassed: allCriticalPassed, results };",
      "}"
    ],
    "description": "TDD audit tasks method for AI4Devs compliance testing"
  },
  "Retro Neon Styling": {
    "prefix": "neon-style",
    "body": [
      "// Neon color palette - AI4Devs Standard",
      "const NEON_COLORS = {",
      "  cyan: '#00ffff',",
      "  magenta: '#ff00ff',",
      "  yellow: '#ffff00',",
      "  green: '#00ff00',",
      "  white: '#ffffff',",
      "  dark: '#000011'",
      "};",
      "",
      "function drawNeonText(text, x, y, color = NEON_COLORS.cyan, size = 24) {",
      "  ctx.save();",
      "  ",
      "  // Neon glow effect",
      "  ctx.shadowColor = color;",
      "  ctx.shadowBlur = 10;",
      "  ctx.lineWidth = 2;",
      "  ",
      "  // Text styling",
      "  ctx.font = `${size}px 'Courier New', monospace`;",
      "  ctx.fillStyle = color;",
      "  ctx.strokeStyle = color;",
      "  ",
      "  // Draw text with glow",
      "  ctx.fillText(text, x, y);",
      "  ctx.strokeText(text, x, y);",
      "  ",
      "  ctx.restore();",
      "}",
      "",
      "function drawNeonRect(x, y, width, height, color = NEON_COLORS.cyan) {",
      "  ctx.save();",
      "  ",
      "  ctx.strokeStyle = color;",
      "  ctx.shadowColor = color;",
      "  ctx.shadowBlur = 8;",
      "  ctx.lineWidth = 2;",
      "  ",
      "  ctx.strokeRect(x, y, width, height);",
      "  ",
      "  ctx.restore();",
      "}"
    ],
    "description": "Retro neon styling utilities for consistent game aesthetics"
  },
  "Mobile Touch Controls": {
    "prefix": "touch-controls",
    "body": [
      "class TouchControls {",
      "  constructor(canvas) {",
      "    this.canvas = canvas;",
      "    this.touches = new Map();",
      "    this.setupTouchEvents();",
      "  }",
      "  ",
      "  setupTouchEvents() {",
      "    this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });",
      "    this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });",
      "    this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: false });",
      "  }",
      "  ",
      "  getTouchPosition(touch) {",
      "    const rect = this.canvas.getBoundingClientRect();",
      "    const scaleX = this.canvas.width / rect.width;",
      "    const scaleY = this.canvas.height / rect.height;",
      "    ",
      "    return {",
      "      x: (touch.clientX - rect.left) * scaleX,",
      "      y: (touch.clientY - rect.top) * scaleY",
      "    };",
      "  }",
      "  ",
      "  handleTouchStart(e) {",
      "    e.preventDefault();",
      "    ",
      "    for (let touch of e.changedTouches) {",
      "      const pos = this.getTouchPosition(touch);",
      "      this.touches.set(touch.identifier, {",
      "        startX: pos.x,",
      "        startY: pos.y,",
      "        currentX: pos.x,",
      "        currentY: pos.y,",
      "        startTime: performance.now()",
      "      });",
      "    }",
      "    ",
      "    ${1:// Handle touch start}",
      "  }",
      "  ",
      "  handleTouchMove(e) {",
      "    e.preventDefault();",
      "    ",
      "    for (let touch of e.changedTouches) {",
      "      if (this.touches.has(touch.identifier)) {",
      "        const pos = this.getTouchPosition(touch);",
      "        const touchData = this.touches.get(touch.identifier);",
      "        touchData.currentX = pos.x;",
      "        touchData.currentY = pos.y;",
      "      }",
      "    }",
      "    ",
      "    ${2:// Handle touch move}",
      "  }",
      "  ",
      "  handleTouchEnd(e) {",
      "    e.preventDefault();",
      "    ",
      "    for (let touch of e.changedTouches) {",
      "      if (this.touches.has(touch.identifier)) {",
      "        const touchData = this.touches.get(touch.identifier);",
      "        const duration = performance.now() - touchData.startTime;",
      "        const deltaX = touchData.currentX - touchData.startX;",
      "        const deltaY = touchData.currentY - touchData.startY;",
      "        ",
      "        // Detect swipe gestures",
      "        if (Math.abs(deltaX) > 50 || Math.abs(deltaY) > 50) {",
      "          if (Math.abs(deltaX) > Math.abs(deltaY)) {",
      "            // Horizontal swipe",
      "            if (deltaX > 0) {",
      "              ${3:// Swipe right}",
      "            } else {",
      "              ${4:// Swipe left}",
      "            }",
      "          } else {",
      "            // Vertical swipe",
      "            if (deltaY > 0) {",
      "              ${5:// Swipe down}",
      "            } else {",
      "              ${6:// Swipe up}",
      "            }",
      "          }",
      "        } else if (duration < 300) {",
      "          ${7:// Tap gesture}",
      "        }",
      "        ",
      "        this.touches.delete(touch.identifier);",
      "      }",
      "    }",
      "  }",
      "}"
    ],
    "description": "Mobile touch controls with gesture detection for retro games"
  },
  "Audio Manager": {
    "prefix": "retro-audio",
    "body": [
      "class RetroAudioManager {",
      "  constructor() {",
      "    this.audioContext = null;",
      "    this.sounds = new Map();",
      "    this.enabled = true;",
      "    this.volume = 0.5;",
      "    ",
      "    this.initAudioContext();",
      "  }",
      "  ",
      "  initAudioContext() {",
      "    try {",
      "      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();",
      "    } catch (e) {",
      "      console.warn('Web Audio API not supported. Audio disabled.');",
      "      this.enabled = false;",
      "    }",
      "  }",
      "  ",
      "  createBeep(frequency = 440, duration = 0.1, type = 'square') {",
      "    if (!this.enabled || !this.audioContext) return;",
      "    ",
      "    const oscillator = this.audioContext.createOscillator();",
      "    const gainNode = this.audioContext.createGain();",
      "    ",
      "    oscillator.connect(gainNode);",
      "    gainNode.connect(this.audioContext.destination);",
      "    ",
      "    oscillator.type = type;",
      "    oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);",
      "    ",
      "    gainNode.gain.setValueAtTime(this.volume * 0.1, this.audioContext.currentTime);",
      "    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);",
      "    ",
      "    oscillator.start(this.audioContext.currentTime);",
      "    oscillator.stop(this.audioContext.currentTime + duration);",
      "  }",
      "  ",
      "  playPowerUp() {",
      "    this.createBeep(523, 0.1, 'triangle'); // C5",
      "    setTimeout(() => this.createBeep(659, 0.1, 'triangle'), 100); // E5",
      "    setTimeout(() => this.createBeep(784, 0.2, 'triangle'), 200); // G5",
      "  }",
      "  ",
      "  playGameOver() {",
      "    this.createBeep(392, 0.2, 'sawtooth'); // G4",
      "    setTimeout(() => this.createBeep(349, 0.2, 'sawtooth'), 200); // F4",
      "    setTimeout(() => this.createBeep(311, 0.4, 'sawtooth'), 400); // D#4",
      "  }",
      "  ",
      "  playBlip() {",
      "    this.createBeep(800, 0.05, 'square');",
      "  }",
      "  ",
      "  setVolume(volume) {",
      "    this.volume = Math.max(0, Math.min(1, volume));",
      "  }",
      "  ",
      "  toggle() {",
      "    this.enabled = !this.enabled;",
      "    return this.enabled;",
      "  }",
      "}"
    ],
    "description": "Retro audio manager with 8-bit style sound effects"
  }
}
